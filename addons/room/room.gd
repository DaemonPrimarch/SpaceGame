tool

extends Node2D

signal player_entered(player)
signal room_lit()
signal room_darkened()

export var dark = true setget set_dark, is_dark 
export var dark_color = Color(0,0,0)
export var auto_generate_camera_limiter = true

func _ready():
	if(Engine.editor_hint and not has_node("terrain")):
		var ter = preload("res://nodes/terrain.tscn").instance()
		
		add_child(ter)
		
		ter.set_owner(get_tree().get_edited_scene_root())
		
	if(Engine.editor_hint and not has_node("player")):
		var play = preload("res://nodes/entities/player/puppet_player.tscn").instance()
		
		add_child(play)
		
		play.set_owner(get_tree().get_edited_scene_root())
	
	if(Engine.editor_hint and not has_node("CanvasModulate")):
		var mod = CanvasModulate.new()
		add_child(mod)
		
		mod.set_owner(get_tree().get_edited_scene_root())
		
		mod.color = Color(1,1,1,1)
		
		mod.set_meta("_edit_lock_", true)
	
	if(Engine.editor_hint and auto_generate_camera_limiter):
		generate_camera_limiter()
	
	connect("player_entered", self, "_on_room_player_entered")
	connect("room_darkened", self, "_on_room_room_darkened")
	connect("room_lit", self, "_on_room_room_lit")
	
	_iterate_over_children(self)

func _iterate_over_children(node):
	if(node.is_in_group("entity")):
		node.emit_signal("room_entered")
	
	for child in node.get_children():
		_iterate_over_children(child)
		
func _physics_process(delta):
	pass

func set_dark(val):
	dark = val
	
	if(not val):
		call_deferred("emit_signal","room_lit")
	else:
		call_deferred("emit_signal","room_darkened")

func is_dark():
	return dark

func _draw():
	pass

func _on_room_room_darkened():
	get_node("CanvasModulate").color = dark_color

func _on_room_room_lit():
	get_node("CanvasModulate").color = Color(1,1,1)

func generate_camera_limiter():
	print("GENERATED CAMERA LIMITER")
	
	var min_point = Vector2(10000, 10000)
	
	for tile in get_node("terrain").get_used_cells():
		if(tile.x < min_point.x):
			min_point = tile
	
	var scrolling_point = min_point
	var polygon = []
	var terrain = get_node("terrain")
	var rect = terrain.get_used_rect()
	
	if(not rect.has_no_area()):
		polygon.push_back(rect.position * terrain.cell_size)
		polygon.push_back((rect.position + rect.size * Vector2(0, 1)) * terrain.cell_size)
		polygon.push_back((rect.position + rect.size) * terrain.cell_size)
		polygon.push_back((rect.position + rect.size * Vector2(1, 0)) * terrain.cell_size)
		
		var collision_polygon
		
		if(not has_node("AutoGeneratedCameraLimitArea")):
			var limit_area = preload("res://addons/extended_camera_2D/camera_limit_area.gd").new()
			collision_polygon = preload("res://addons/extended_collision_polygon_2D/extended_collision_polygon_2D.gd").new()
				
			limit_area.visible = false
			
			collision_polygon.name = "CollisionPolygon2D"
			
			limit_area.add_child(collision_polygon)
			limit_area.name = "AutoGeneratedCameraLimitArea"
			add_child(limit_area)
			collision_polygon.set_owner(get_tree().get_edited_scene_root())
			limit_area.set_owner(get_tree().get_edited_scene_root())
		else:
			collision_polygon = get_node("AutoGeneratedCameraLimitArea").get_node("CollisionPolygon2D")
		
		collision_polygon.polygon = polygon

func _on_room_player_entered(player):
	get_node("/root/GUI").set_room_name(get_node("/root/ROOM_MANAGER").get_path_of_room(self))
